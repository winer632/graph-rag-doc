<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph-RAG Technical Proposal (KAG Enhanced)</title>
    <!-- å¼•å…¥ Mermaid -->
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
    <!-- å¼•å…¥ä»£ç é«˜äº® -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <style>
        :root {
            --primary-color: #2563eb;
            --text-color: #1f2937;
            --bg-color: #ffffff;
            --sidebar-bg: #f3f4f6;
            --code-bg: #282c34;
            --border-color: #e5e7eb;
            --warning-bg: #fff7ed;
            --warning-border: #fdba74;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            display: flex;
            min-height: 100vh;
        }

        /* =========================================
           å…³é”®ä¿®å¤ï¼šè¯­è¨€åˆ‡æ¢ä¸ Mermaid å…¼å®¹æ€§å¤„ç†
           ========================================= */
        
        /* 1. æ–‡æœ¬å†…å®¹çš„åˆ‡æ¢ */
        .lang-en { display: none; }
        
        body.en-mode .lang-zh { display: none; }
        body.en-mode .lang-en { display: block; }
        body.en-mode span.lang-en { display: inline; }

        /* 2. Mermaid å›¾è¡¨çš„åˆ‡æ¢ï¼šä½¿ç”¨ height: 0 éšè—ä»¥ä¿æŒæ¸²æŸ“ */
        body:not(.en-mode) .mermaid-container.lang-en {
            display: block !important;
            height: 0 !important;
            overflow: hidden !important;
            visibility: hidden !important;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important;
            opacity: 0;
        }

        body.en-mode .mermaid-container.lang-zh {
            display: block !important;
            height: 0 !important;
            overflow: hidden !important;
            visibility: hidden !important;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important;
            opacity: 0;
        }

        /* ========================================= */

        /* è¯­è¨€é€‰æ‹©å™¨æ ·å¼ */
        .lang-selector {
            position: fixed;
            top: 1rem;
            right: 2rem;
            z-index: 1000;
            background: white;
            padding: 0.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 1px solid var(--border-color);
        }
        
        .lang-selector select {
            padding: 0.3rem 0.5rem;
            font-size: 0.9rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }

        /* ä¾§è¾¹æ å¯¼èˆª */
        nav {
            width: 260px;
            background-color: var(--sidebar-bg);
            padding: 2rem 1rem;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
            display: none; /* ç§»åŠ¨ç«¯é»˜è®¤éšè— */
        }

        nav ul {
            list-style: none;
            padding: 0;
        }

        nav li {
            margin-bottom: 0.8rem;
        }

        nav a {
            text-decoration: none;
            color: #4b5563;
            font-size: 0.95rem;
            transition: color 0.2s;
        }

        nav a:hover, nav a.active {
            color: var(--primary-color);
            font-weight: 600;
        }

        nav h3 {
            font-size: 0.85rem;
            text-transform: uppercase;
            color: #9ca3af;
            margin-bottom: 1rem;
            letter-spacing: 0.05em;
        }

        /* ä¸»å†…å®¹åŒº */
        main {
            flex: 1;
            padding: 2rem 4rem;
            max-width: 1000px;
            margin-left: 260px; /* ç•™å‡ºä¾§è¾¹æ å®½åº¦ */
        }

        h1 { font-size: 2.25rem; margin-bottom: 1.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 1rem; }
        h2 { font-size: 1.75rem; margin-top: 3rem; margin-bottom: 1rem; color: #111827; }
        h3 { font-size: 1.4rem; margin-top: 2rem; margin-bottom: 0.8rem; color: #374151; }
        h4 { font-size: 1.1rem; margin-top: 1.5rem; font-weight: 600; }

        p { margin-bottom: 1rem; }

        ul, ol { margin-bottom: 1rem; padding-left: 1.5rem; }
        li { margin-bottom: 0.5rem; }

        /* ä»£ç å—æ ·å¼ */
        pre {
            background-color: var(--code-bg);
            border-radius: 8px;
            padding: 1rem;
            overflow-x: auto;
            margin: 1.5rem 0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        code {
            font-family: "Fira Code", Consolas, Monaco, monospace;
            font-size: 0.9rem;
        }

        /* å¼•ç”¨å— */
        blockquote {
            border-left: 4px solid var(--primary-color);
            background-color: #eff6ff;
            margin: 1.5rem 0;
            padding: 1rem;
            border-radius: 0 8px 8px 0;
        }

        /* è­¦å‘Š/æ³¨æ„å— */
        .warning-box {
            border-left: 4px solid var(--warning-border);
            background-color: var(--warning-bg);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        /* Mermaid å›¾è¡¨å®¹å™¨ */
        .mermaid-container {
            background: #fff;
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 2rem 0;
            text-align: center;
            min-height: 50px; 
        }

        /* å‚è€ƒæ–‡çŒ®åˆ—è¡¨ */
        .ref-list li {
            margin-bottom: 0.8rem;
            word-break: break-all;
        }
        .ref-list a {
            color: var(--primary-color);
            text-decoration: none;
        }
        .ref-list a:hover {
            text-decoration: underline;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (min-width: 1024px) {
            nav { display: block; }
        }

        @media (max-width: 1023px) {
            main { margin-left: 0; padding: 1.5rem; }
            nav { display: none; }
            .lang-selector { top: 0.5rem; right: 0.5rem; }
        }
    </style>
</head>
<!-- é»˜è®¤å¼€å¯è‹±æ–‡æ¨¡å¼ -->
<body class="en-mode">

    <!-- è¯­è¨€åˆ‡æ¢å™¨ -->
    <div class="lang-selector">
        <select id="languageSelect" onchange="switchLanguage(this.value)">
            <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡ (Chinese)</option>
            <option value="en" selected>ğŸ‡ºğŸ‡¸ English</option>
        </select>
    </div>

    <!-- ä¾§è¾¹æ ç›®å½• -->
    <nav>
        <h3>
            <span class="lang-zh">ç›®å½•</span>
            <span class="lang-en">Table of Contents</span>
        </h3>
        <ul>
            <!-- æ–°å¢èƒŒæ™¯ç« èŠ‚ -->
            <li><a href="#background">
                <span class="lang-zh">0. èƒŒæ™¯ä¸åŠ¨æœº</span>
                <span class="lang-en">0. Background & Motivation</span>
            </a></li>
            <li><a href="#overview">
                <span class="lang-zh">1. æ¦‚è¿°</span>
                <span class="lang-en">1. Overview</span>
            </a></li>
            <li><a href="#architecture">
                <span class="lang-zh">2. æ€»ä½“æ¶æ„å›¾</span>
                <span class="lang-en">2. Architecture</span>
            </a></li>
            <li><a href="#pipeline-data">
                <span class="lang-zh">3. ç¦»çº¿æ•°æ®å¤„ç†æµç¨‹</span>
                <span class="lang-en">3. Offline Data Pipeline</span>
            </a></li>
            <ul>
                <li><a href="#schema">
                    <span class="lang-zh">3.1 Schema å®šä¹‰</span>
                    <span class="lang-en">3.1 Schema Definition</span>
                </a></li>
                <li><a href="#parsing">
                    <span class="lang-zh">3.2 æ–‡æ¡£è§£æä¸åˆ‡åˆ†</span>
                    <span class="lang-en">3.2 Parsing & Chunking</span>
                </a></li>
                <li><a href="#extraction">
                    <span class="lang-zh">3.3 LLM ä¿¡æ¯æŠ½å–</span>
                    <span class="lang-en">3.3 LLM Extraction</span>
                </a></li>
                <li><a href="#normalization">
                    <span class="lang-zh">3.4 å®ä½“å½’ä¸€åŒ–</span>
                    <span class="lang-en">3.4 Normalization</span>
                </a></li>
                <li><a href="#indexing">
                    <span class="lang-zh">3.5 äº’ç´¢å¼•æ„å»º</span>
                    <span class="lang-en">3.5 Mutual Indexing</span>
                </a></li>
            </ul>
            <li><a href="#pipeline-query">
                <span class="lang-zh">4. åœ¨çº¿é—®ç­”å¤„ç†æµç¨‹</span>
                <span class="lang-en">4. Online Query Pipeline</span>
            </a></li>
            <ul>
                <li><a href="#planning">
                    <span class="lang-zh">4.1 é€»è¾‘è§„åˆ’</span>
                    <span class="lang-en">4.1 Logic Planning</span>
                </a></li>
                <li><a href="#reasoning">
                    <span class="lang-zh">4.2 æ¨ç†ä¸æ£€ç´¢</span>
                    <span class="lang-en">4.2 Reasoning & Retrieval</span>
                </a></li>
            </ul>
            <li><a href="#analysis">
                <span class="lang-zh">5. æ–¹æ¡ˆåˆ†æä¸å·®è·å¯¹æ¯”</span>
                <span class="lang-en">5. Analysis & Gap Check</span>
            </a></li>
            <!-- æ–°å¢å‚è€ƒæ–‡çŒ® -->
            <li><a href="#references">
                <span class="lang-zh">6. å‚è€ƒæ–‡çŒ®</span>
                <span class="lang-en">6. References</span>
            </a></li>
        </ul>
    </nav>

    <!-- ä¸»å†…å®¹ -->
    <main>
        <header>
            <h1>
                <span class="lang-zh">Graph-RAG ç³»ç»ŸæŠ€æœ¯æ–¹æ¡ˆ (KAG Enhanced)</span>
                <span class="lang-en">Graph-RAG Technical Proposal (KAG Enhanced)</span>
            </h1>
            <p>
                <!-- ç‰ˆæœ¬å·æ›´æ–°ä¸º v2.2 -->
                <span class="lang-zh"><strong>ç‰ˆæœ¬ï¼š</strong> v2.2 | <strong>çŠ¶æ€ï¼š</strong> Draft | <strong>ä½œè€…ï¼š</strong> ç‹æ¬£é‘«</span>
                <span class="lang-en"><strong>Version:</strong> v2.2 | <strong>Status:</strong> Draft | <strong>Author:</strong> Xinxin Wang</span>
            </p>
        </header>

        <!-- æ–°å¢èƒŒæ™¯ä¸åŠ¨æœºç« èŠ‚ -->
        <section id="background">
            <h2>
                <span class="lang-zh">0. èƒŒæ™¯ä¸åŠ¨æœº</span>
                <span class="lang-en">0. Background & Motivation</span>
            </h2>
            <div class="warning-box" style="background-color: #f0f9ff; border-left-color: #2563eb;">
                <p class="lang-zh">
                    æˆ‘ä»¬åŸæœ¬å·²ç»æœ‰ä¸€ä¸ªæˆç†Ÿçš„ RAG ç³»ç»Ÿäº†ï¼Œç°åœ¨æƒ³è¦å¼•å…¥çŸ¥è¯†å›¾è°±ä»¥å¢å¼ºæ¨ç†èƒ½åŠ›ã€‚ç„¶è€Œï¼Œå¦‚æœç›´æ¥å¼•å…¥å®Œæ•´çš„ KAG å’Œ OpenSPG æ¡†æ¶ï¼Œæ˜¾å¾—è¿‡äºåšé‡ï¼Œä¸”éš¾ä»¥ä¸ç°æœ‰ç³»ç»Ÿæ¶æ„æ·±åº¦èåˆã€‚
                </p>
                <p class="lang-zh">
                    å› æ­¤ï¼Œæœ¬æ–¹æ¡ˆå‚è€ƒäº† KAG å’Œ OpenSPG çš„æ ¸å¿ƒæ€æƒ³ï¼Œè®¾è®¡äº†ä¸€å¥—<strong>åŸºäºåŸæœ‰ RAG ç³»ç»Ÿå¼•å…¥çŸ¥è¯†å›¾è°±çš„è½»é‡åŒ–æ–¹æ¡ˆ</strong>ã€‚è¿™å¯ä»¥è¢«è§†ä¸º KAG+OpenSPG çš„ç®€åŒ–ç‰ˆå®ç°ï¼Œæ—¨åœ¨ä»¥æœ€å°çš„æ”¹é€ æˆæœ¬è·å–å›¾è°±å¸¦æ¥çš„é€»è¾‘å¢å¼ºã€‚
                </p>
                
                <p class="lang-en">
                    We already possess a mature RAG system and wish to introduce Knowledge Graphs to enhance reasoning capabilities. However, directly adopting the full KAG and OpenSPG frameworks appears too heavy and difficult to integrate deeply with our existing architecture.
                </p>
                <p class="lang-en">
                    Therefore, drawing inspiration from the core philosophies of KAG and OpenSPG, we have designed a <strong>lightweight solution to incorporate Knowledge Graphs based on our original RAG system</strong>. This can be considered a simplified implementation of KAG+OpenSPG, aiming to gain logic enhancements with minimal refactoring costs.
                </p>
            </div>
        </section>

        <section id="overview">
            <h2>
                <span class="lang-zh">1. æ¦‚è¿°</span>
                <span class="lang-en">1. Overview</span>
            </h2>
            <p class="lang-zh">æœ¬æ–¹æ¡ˆæ—¨åœ¨æ„å»ºä¸€ä¸ªç»“åˆçŸ¥è¯†å›¾è°±ï¼ˆKnowledge Graph, KGï¼‰ä¸å¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰çš„å·¥ä¸šçº§ RAG ç³»ç»Ÿã€‚å‚è€ƒ <strong>OpenSPG/KAG</strong> çš„è®¾è®¡ç†å¿µï¼Œé€šè¿‡å¼•å…¥ <strong>Schema çº¦æŸ</strong>ã€<strong>äº’ç´¢å¼•æœºåˆ¶</strong> å’Œ <strong>é€»è¾‘æ±‚è§£å™¨</strong>ï¼Œè§£å†³ä¼ ç»Ÿ RAG åœ¨å¤„ç†å¤æ‚é€»è¾‘ã€å¤šè·³æ¨ç†åŠä¸“ä¸šé¢†åŸŸçŸ¥è¯†ç²¾åº¦ä¸Šçš„ä¸è¶³ã€‚</p>
            <p class="lang-en">This proposal aims to build an industrial-grade RAG system combining Knowledge Graph (KG) and Large Language Models (LLM). Referencing the design philosophy of <strong>OpenSPG/KAG</strong>, it introduces <strong>Schema Constraints</strong>, <strong>Mutual Indexing</strong>, and a <strong>Logic Solver</strong> to address the limitations of traditional RAG in handling complex logic, multi-hop reasoning, and domain knowledge precision.</p>
            
            <blockquote>
                <strong class="lang-zh">æ ¸å¿ƒç†å¿µï¼š</strong>
                <strong class="lang-en">Core Concepts:</strong><br>
                <span class="lang-zh">â€¢ <strong>Schema-Firstï¼š</strong> é¢„å®šä¹‰é¢†åŸŸæœ¬ä½“ï¼ˆå®ä½“/æ¦‚å¿µ/äº‹ä»¶ï¼‰ï¼Œç¡®ä¿çŸ¥è¯†æŠ½å–çš„è§„èŒƒæ€§ã€‚</span>
                <span class="lang-en">â€¢ <strong>Schema-First:</strong> Pre-define domain ontology (Entities/Concepts/Events) to ensure standardized knowledge extraction.</span><br>
                <span class="lang-zh">â€¢ <strong>äº’ç´¢å¼• (Mutual Indexing)ï¼š</strong> å»ºç«‹æ–‡æœ¬åˆ‡ç‰‡ä¸å›¾è°±èŠ‚ç‚¹çš„åŒå‘æ˜ å°„ï¼Œå®ç°æ··åˆæ£€ç´¢ã€‚</span>
                <span class="lang-en">â€¢ <strong>Mutual Indexing:</strong> Establish bidirectional mapping between text chunks and graph nodes to enable hybrid retrieval.</span><br>
                <span class="lang-zh">â€¢ <strong>é€»è¾‘æ±‚è§£ï¼š</strong> å°†è‡ªç„¶è¯­è¨€è½¬åŒ–ä¸ºé€»è¾‘è®¡åˆ’ï¼Œæ”¯æŒè®¡ç®—ä¸æ¨ç†ï¼Œè€Œéä»…é è¯­ä¹‰åŒ¹é…ã€‚</span>
                <span class="lang-en">â€¢ <strong>Logic Solver:</strong> Convert natural language into logical plans, supporting calculation and reasoning rather than just semantic matching.</span>
            </blockquote>
        </section>

        <section id="architecture">
            <h2>
                <span class="lang-zh">2. æ€»ä½“æ¶æ„å›¾</span>
                <span class="lang-en">2. Architecture Diagram</span>
            </h2>
            <div class="mermaid-container lang-zh">
                <div class="mermaid">
graph TD
    subgraph "ç¦»çº¿æ•°æ®å¤„ç†æµç¨‹ (Data Pipeline)"
        Init["Schema/Ontology å®šä¹‰"] --> A["åŸå§‹æ–‡æ¡£ PDF/Word/MD"]
        A --> B("æ–‡æ¡£è§£æ Parsing")
        B --> C("æ–‡æœ¬åˆ‡åˆ† Chunking")
        C --> D{"LLM ä¿¡æ¯æŠ½å–"}
        D -->|åŸºäº Schema| E["å®ä½“/æ¦‚å¿µ/äº‹ä»¶"]
        D -->|æå–å…³ç³»| F["å…³ç³» Relation"]
        E & F --> G("å®ä½“å½’ä¸€åŒ– Normalization")
        G --> H("å›¾è°±æ„å»º Graph Construction")
        H --> I[("å›¾æ•°æ®åº“ Neo4j")]
        C --> J[("å‘é‡/æ–‡æœ¬æ•°æ®åº“")]
        I <-->|"äº’ç´¢å¼• Mutual Indexing"| J
    end

    subgraph "åœ¨çº¿é—®ç­”å¤„ç†æµç¨‹ (Query Pipeline)"
        U["ç”¨æˆ·æé—®"] --> V("é€»è¾‘è§„åˆ’ Logic Planning")
        V --> W("æ¨ç†ä¸æ£€ç´¢ Reasoning & Retrieval")
        W --> X("è·å–å…³è” Chunk å†…å®¹")
        X --> Y("ä¸Šä¸‹æ–‡é‡ç»„ Context Merge")
        Y --> Z("LLM ç­”æ¡ˆç”Ÿæˆ")
        Z --> Ans["æœ€ç»ˆå›ç­”"]
    end
                </div>
            </div>
            <div class="mermaid-container lang-en">
                <div class="mermaid">
graph TD
    subgraph "Offline Data Pipeline"
        Init[Schema/Ontology Def] --> A[Raw Docs PDF/Word/MD]
        A --> B(Doc Parsing)
        B --> C(Text Chunking)
        C --> D{LLM Extraction}
        D -->|Schema Based| E[Entity/Concept/Event]
        D -->|Extract Relations| F[Relation]
        E & F --> G(Normalization)
        G --> H(Graph Construction)
        H --> I[(GraphDB Neo4j)]
        C --> J[(Vector/Text DB)]
        I <-->|Mutual Indexing| J
    end

    subgraph "Online Query Pipeline"
        U[User Query] --> V(Logic Planning)
        V --> W(Reasoning & Retrieval)
        W --> X(Fetch Related Chunks)
        X --> Y(Context Merge)
        Y --> Z(LLM Generation)
        Z --> Ans[Final Answer]
    end
                </div>
            </div>
        </section>

        <section id="pipeline-data">
            <h2>
                <span class="lang-zh">3. ç¦»çº¿æ•°æ®å¤„ç†æµç¨‹</span>
                <span class="lang-en">3. Offline Data Pipeline</span>
            </h2>
            <p class="lang-zh">æ­¤æµç¨‹è´Ÿè´£å°†éç»“æ„åŒ–æ•°æ®è½¬åŒ–ä¸ºç»“æ„åŒ–çŸ¥è¯†å¹¶å…¥åº“ã€‚ä¸ä¼ ç»Ÿ Graph-RAG ä¸åŒï¼Œæˆ‘ä»¬å¼•å…¥äº† <strong>Schema-First</strong> å’Œ <strong>DIKW (Data-Information-Knowledge-Wisdom)</strong> å»ºæ¨¡æ€æƒ³ã€‚</p>
            <p class="lang-en">This pipeline is responsible for converting unstructured data into structured knowledge. Unlike traditional Graph-RAG, we introduce <strong>Schema-First</strong> and <strong>DIKW (Data-Information-Knowledge-Wisdom)</strong> modeling concepts.</p>

            <h3 id="schema">
                <span class="lang-zh">3.1 Schema å®šä¹‰ (Schema-First)</span>
                <span class="lang-en">3.1 Schema Definition (Schema-First)</span>
            </h3>
            <p class="lang-zh">åœ¨è§£ææ–‡æ¡£å‰ï¼Œå¿…é¡»å®šä¹‰é¢†åŸŸçš„ Schemaã€‚è¿™ä¸ä»…æ˜¯ç±»å‹åˆ—è¡¨ï¼Œæ›´æ˜¯å¯¹å±æ€§å’Œé€»è¾‘çš„çº¦æŸã€‚</p>
            <p class="lang-en">Before parsing documents, the domain Schema must be defined. This is not just a list of types, but a constraint on properties and logic.</p>
            
            <!-- ä¸­æ–‡ä»£ç å— -->
            <pre class="lang-zh"><code class="language-python">class SchemaConfig:
    # 1. å®ä½“ (Entity): å…·ä½“å­˜åœ¨çš„å¯¹è±¡
    ENTITIES = ['Person', 'Company', 'Product']
    
    # 2. æ¦‚å¿µ (Concept): æŠ½è±¡çš„åˆ†ç±»æˆ–é¢†åŸŸæœ¯è¯­
    CONCEPTS = ['Industry', 'Technology', 'Regulation']
    
    # 3. äº‹ä»¶ (Event): åŠ¨æ€å‘ç”Ÿçš„åŠ¨ä½œï¼ŒåŒ…å«æ—¶é—´/åœ°ç‚¹
    EVENTS = ['Acquisition', 'Release', 'Lawsuit']
    
    # 4. å±æ€§çº¦æŸ (Properties): å®šä¹‰æ¯ä¸ªç±»å‹å¿…é¡»åŒ…å«çš„å­—æ®µ
    PROPERTIES = {
        'Company': ['revenue', 'employee_count', 'founded_date'],
        'Event': ['event_date', 'location', 'participants']
    }</code></pre>

            <!-- è‹±æ–‡ä»£ç å— -->
            <pre class="lang-en"><code class="language-python">class SchemaConfig:
    # 1. Entity: Concrete existing objects
    ENTITIES = ['Person', 'Company', 'Product']
    
    # 2. Concept: Abstract classifications or domain terms
    CONCEPTS = ['Industry', 'Technology', 'Regulation']
    
    # 3. Event: Dynamic actions, including time/location
    EVENTS = ['Acquisition', 'Release', 'Lawsuit']
    
    # 4. Properties: Define mandatory fields for each type
    PROPERTIES = {
        'Company': ['revenue', 'employee_count', 'founded_date'],
        'Event': ['event_date', 'location', 'participants']
    }</code></pre>

            <h3 id="parsing">
                <span class="lang-zh">3.2 æ–‡æ¡£è§£æä¸åˆ‡åˆ†</span>
                <span class="lang-en">3.2 Document Parsing & Chunking</span>
            </h3>
            <ul>
                <li>
                    <span class="lang-zh"><strong>è¾“å…¥ï¼š</strong> PDF, Word, Markdown, HTML ç­‰æ ¼å¼æ–‡ä»¶ã€‚</span>
                    <span class="lang-en"><strong>Input:</strong> PDF, Word, Markdown, HTML, etc.</span>
                </li>
                <li>
                    <span class="lang-zh"><strong>å¤„ç†é€»è¾‘ï¼š</strong></span>
                    <span class="lang-en"><strong>Processing Logic:</strong></span>
                    <ol>
                        <li>
                            <span class="lang-zh"><strong>åŠ è½½ (Loader)ï¼š</strong> ä½¿ç”¨ autopdf ç­‰å·¥å…·è½¬æ¢ä¸º Markdownã€‚</span>
                            <span class="lang-en"><strong>Loader:</strong> Convert to Markdown using tools like autopdf.</span>
                        </li>
                        <li>
                            <span class="lang-zh"><strong>åˆ‡åˆ† (Splitter)ï¼š</strong> é‡‡ç”¨æ··åˆåˆ‡åˆ†ç­–ç•¥ï¼ˆMarkdown ç»“æ„åŒ–åˆ‡åˆ† + é€’å½’å­—ç¬¦åˆ‡åˆ†ï¼‰ï¼Œå¹¶å¯¹ç‰¹æ®Šå†…å®¹ï¼ˆå›¾ç‰‡ã€è¡¨æ ¼ã€ä»£ç å—ï¼‰è¿›è¡Œä¿æŠ¤ã€‚</span>
                            <span class="lang-en"><strong>Splitter:</strong> Use hybrid splitting strategy (Markdown structural splitting + recursive character splitting), protecting special content (images, tables, code blocks).</span>
                        </li>
                        <li>
                            <span class="lang-zh"><strong>ç´¢å¼•åŒ–ï¼š</strong> ç”Ÿæˆå”¯ä¸€ <code>chunk_id</code>ã€‚</span>
                            <span class="lang-en"><strong>Indexing:</strong> Generate unique <code>chunk_id</code>.</span>
                        </li>
                    </ol>
                </li>
            </ul>

            <h3 id="extraction">
                <span class="lang-zh">3.3 LLM ä¿¡æ¯æŠ½å–</span>
                <span class="lang-en">3.3 LLM-based Extraction</span>
            </h3>
            <p class="lang-zh">åˆ©ç”¨ LLM è¿›è¡ŒæŠ½å–æ—¶ï¼Œå°† Schema å®šä¹‰æ³¨å…¥ Promptï¼Œå¼ºåˆ¶ LLM è¾“å‡ºç¬¦åˆè§„èŒƒçš„ç»“æ„åŒ–æ•°æ®ï¼Œå¹¶æ˜¾å¼åŒºåˆ†å®ä½“ã€æ¦‚å¿µå’Œäº‹ä»¶ã€‚</p>
            <p class="lang-en">When using LLM for extraction, inject the Schema definition into the Prompt to force the LLM to output standardized structured data, explicitly distinguishing between entities, concepts, and events.</p>
            
            <pre class="lang-zh"><code class="language-python">def extract_knowledge_from_chunk(text_chunk, schema_config):
    """
    åŸºäº Schema çš„çŸ¥è¯†æŠ½å–
    """
    system_prompt = f"""
    ä½ æ˜¯ä¸€ä¸ªé¢†åŸŸçŸ¥è¯†å›¾è°±æ„å»ºä¸“å®¶ã€‚è¯·æ ¹æ®ä»¥ä¸‹ Schema å®šä¹‰ä»æ–‡æœ¬ä¸­æå–çŸ¥è¯†ã€‚
    
    ã€Schema å®šä¹‰ã€‘
    - å®ä½“ç±»å‹: {schema_config.ENTITIES}
    - æ¦‚å¿µç±»å‹: {schema_config.CONCEPTS}
    - äº‹ä»¶ç±»å‹: {schema_config.EVENTS} (æ³¨æ„æå–æ—¶é—´ event_date)
    - å±æ€§çº¦æŸ: {schema_config.PROPERTIES}
    
    ã€è¾“å‡ºè¦æ±‚ã€‘
    1. ä¸¥æ ¼éµå®ˆç±»å‹å®šä¹‰ï¼Œä¸è¦åˆ›é€  Schema ä¹‹å¤–çš„ç±»å‹ã€‚
    2. å¯¹äºäº‹ä»¶ï¼Œå¿…é¡»æå–æ—¶é—´è¦ç´ ï¼Œä»¥ä¾¿æ„å»ºæ—¶åºå…³ç³»ã€‚
    3. è¾“å‡ºæ ¼å¼ä¸º JSONã€‚
    """
    
    # è°ƒç”¨ LLM æ‰§è¡ŒæŠ½å–
    return call_llm(system_prompt, text_chunk)</code></pre>

            <pre class="lang-en"><code class="language-python">def extract_knowledge_from_chunk(text_chunk, schema_config):
    """
    Schema-based Knowledge Extraction
    """
    system_prompt = f"""
    You are a domain knowledge graph expert. Extract knowledge from the text based on the following Schema.
    
    [Schema Definition]
    - Entity Types: {schema_config.ENTITIES}
    - Concept Types: {schema_config.CONCEPTS}
    - Event Types: {schema_config.EVENTS} (Note: extract event_date)
    - Property Constraints: {schema_config.PROPERTIES}
    
    [Output Requirements]
    1. Strictly adhere to type definitions; do not invent types outside the Schema.
    2. For events, time elements must be extracted to build temporal relations.
    3. Output format must be JSON.
    """
    
    # Call LLM for extraction
    return call_llm(system_prompt, text_chunk)</code></pre>

            <h3 id="normalization">
                <span class="lang-zh">3.4 å®ä½“å½’ä¸€åŒ– (Normalization)</span>
                <span class="lang-en">3.4 Entity Normalization</span>
            </h3>
            <p class="lang-zh">é‡‡ç”¨å¤šçº§æ¼æ–—æœºåˆ¶ï¼š<strong>å­—é¢åŒ¹é… -> è¯­ä¹‰ç›¸ä¼¼åº¦ -> LLM æ·±åº¦è£å†³</strong>ï¼Œè§£å†³å¤šæºæ•°æ®èåˆé—®é¢˜ã€‚</p>
            <p class="lang-en">Adopts a multi-stage funnel mechanism: <strong>Literal Match -> Semantic Similarity -> LLM Deep Judgment</strong>, solving multi-source data fusion issues.</p>
            
            <pre class="lang-zh"><code class="language-python">def is_same_entity(new_node, existing_node):
    # 1. æé€Ÿé€šé“ï¼šå­—é¢å®Œå…¨ä¸€è‡´
    if new_node.name == existing_node.name: return True
    
    # 2. å‘é‡ç›¸ä¼¼åº¦æ£€æŸ¥
    sim = cosine_similarity(new_node.embedding, existing_node.embedding)
    if sim < 0.6: return False # å¿«é€Ÿæ‹’ç»
    
    # 3. LLM æ·±åº¦è£å†³ (å¤„ç†åˆ«åã€å…¨ç§°ç®€ç§°ã€ç‰ˆæœ¬å·ç­‰å¤æ‚æƒ…å†µ)
    if sim > 0.92: return True # å¿«é€Ÿé€šè¿‡
    
    return llm_judge(new_node, existing_node)</code></pre>

            <pre class="lang-en"><code class="language-python">def is_same_entity(new_node, existing_node):
    # 1. Fast Track: Exact literal match
    if new_node.name == existing_node.name: return True
    
    # 2. Vector Similarity Check
    sim = cosine_similarity(new_node.embedding, existing_node.embedding)
    if sim < 0.6: return False # Fast reject
    
    # 3. LLM Deep Judgment (Handle aliases, abbreviations, versions, etc.)
    if sim > 0.92: return True # Fast pass
    
    return llm_judge(new_node, existing_node)</code></pre>

            <h3 id="indexing">
                <span class="lang-zh">3.5 äº’ç´¢å¼•æ„å»º (Mutual Indexing)</span>
                <span class="lang-en">3.5 Mutual Indexing Construction</span>
            </h3>
            <p class="lang-zh">è¿™æ˜¯ KAG æ¶æ„çš„æ ¸å¿ƒã€‚æˆ‘ä»¬éœ€è¦å»ºç«‹å‘é‡ç´¢å¼•ä¸å›¾è°±ç´¢å¼•çš„åŒå‘æ˜ å°„ï¼Œä»¥æ”¯æŒæ··åˆæ£€ç´¢ã€‚ä¸ºäº†ä¿è¯æ•°æ®ä¸€è‡´æ€§ï¼Œé‡‡ç”¨<strong>â€œå¤„ç†å®Œå†å…¥åº“â€</strong>çš„æµæ°´çº¿æ¨¡å¼ã€‚</p>
            <p class="lang-en">This is the core of the KAG architecture. We need to establish a bidirectional mapping between vector indices and graph indices to support hybrid retrieval. To ensure data consistency, a <strong>"Process then Commit"</strong> pipeline pattern is adopted.</p>
            
            <div class="mermaid-container lang-zh">
                <div class="mermaid">
sequenceDiagram
    participant Doc as æ–‡æ¡£å¤„ç†
    participant LLM as LLMæŠ½å–
    participant Norm as å½’ä¸€åŒ–æ¨¡å—
    participant GraphDB as å›¾æ•°æ®åº“(Neo4j)
    participant VectorDB as å‘é‡æ•°æ®åº“
    
    Doc->>Doc: 1. åˆ‡åˆ†æ–‡æ¡£ï¼Œç”Ÿæˆ chunk_id (UUID)
    Doc->>LLM: 2. è¾“å…¥ Chunk æ–‡æœ¬
    LLM-->>Doc: è¿”å›å®ä½“æåŠ (Mentions: "Aå…¬å¸")
    
    Doc->>Norm: 3. è¯·æ±‚å½’ä¸€åŒ– ("Aå…¬å¸")
    Norm->>GraphDB: æŸ¥è¯¢/åˆ›å»ºå®ä½“ ID
    GraphDB-->>Norm: è¿”å› entity_id (Company:1001)
    Norm-->>Doc: è¿”å› ID åˆ—è¡¨ [Company:1001]
    
    par å¹¶è¡Œå†™å…¥ (åŒå†™)
        Doc->>GraphDB: 4. å†™å›¾è°±: èŠ‚ç‚¹ Company:1001 å…³è” source_chunk_id
        Doc->>VectorDB: 5. å†™å‘é‡: Chunk å‘é‡ + Metadata {related_ids: [Company:1001]}
    end
                </div>
            </div>
            <div class="mermaid-container lang-en">
                <div class="mermaid">
sequenceDiagram
    participant Doc as Doc Processing
    participant LLM as LLM Extraction
    participant Norm as Normalization
    participant GraphDB as GraphDB(Neo4j)
    participant VectorDB as VectorDB
    
    Doc->>Doc: 1. Chunking, generate chunk_id (UUID)
    Doc->>LLM: 2. Input Chunk Text
    LLM-->>Doc: Return Mentions ("Company A")
    
    Doc->>Norm: 3. Request Normalization ("Company A")
    Norm->>GraphDB: Query/Create Entity ID
    GraphDB-->>Norm: Return entity_id (Company:1001)
    Norm-->>Doc: Return ID List [Company:1001]
    
    par Parallel Write
        Doc->>GraphDB: 4. Write Graph: Node Company:1001 links source_chunk_id
        Doc->>VectorDB: 5. Write Vector: Chunk Vector + Metadata {related_ids: [Company:1001]}
    end
                </div>
            </div>
        </section>

        <section id="pipeline-query">
            <h2>
                <span class="lang-zh">4. åœ¨çº¿é—®ç­”å¤„ç†æµç¨‹</span>
                <span class="lang-en">4. Online Query Pipeline</span>
            </h2>
            <p class="lang-zh">ä»ä¼ ç»Ÿçš„â€œå…³é”®è¯åŒ¹é…â€å‡çº§ä¸ºâ€œé€»è¾‘æ±‚è§£å™¨ (Solver)â€ã€‚</p>
            <p class="lang-en">Upgrading from traditional "Keyword Matching" to a "Logic Solver".</p>

            <h3 id="planning">
                <span class="lang-zh">4.1 é€»è¾‘è§„åˆ’ (Schema-Guided Logic Planning)</span>
                <span class="lang-en">4.1 Schema-Guided Logic Planning</span>
            </h3>
            <p class="lang-zh">åˆ©ç”¨ <strong>Schema çº¦æŸ</strong> å’Œ <strong>KG-Solver</strong>ï¼Œå°†è‡ªç„¶è¯­è¨€è½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„ <strong>KGDSL (é¢†åŸŸç‰¹å®šè¯­è¨€)</strong>ï¼Œå¹¶é€šè¿‡æ ¡éªŒæœºåˆ¶ä¿è¯ç¨³å®šæ€§ã€‚</p>
            <p class="lang-en">Using <strong>Schema Constraints</strong> and <strong>KG-Solver</strong>, natural language is converted into executable <strong>KGDSL (Domain Specific Language)</strong>, with validation mechanisms ensuring stability.</p>
            
            <h4>
                <span class="lang-zh">å¤„ç†æµç¨‹ï¼š</span>
                <span class="lang-en">Process Flow:</span>
            </h4>
            <ol>
                <li>
                    <span class="lang-zh"><strong>å®ä½“é“¾æ¥ (Grounding)ï¼š</strong> é¦–å…ˆå°†é—®é¢˜ä¸­çš„â€œAå…¬å¸â€æ˜ å°„ä¸ºå›¾è°±ä¸­çš„å”¯ä¸€ ID <code>Company:1001</code>ï¼Œè€Œéä»…é æ–‡æœ¬ç”Ÿæˆã€‚</span>
                    <span class="lang-en"><strong>Entity Grounding:</strong> First map "Company A" in the question to the unique ID <code>Company:1001</code> in the graph, rather than relying solely on text generation.</span>
                </li>
                <li>
                    <span class="lang-zh"><strong>Schema çº¦æŸç”Ÿæˆï¼š</strong> å°†é¢†åŸŸ Schemaï¼ˆå¦‚ Company æœ‰ revenue å±æ€§ï¼‰æ³¨å…¥ Promptï¼Œé™åˆ¶ LLM åªèƒ½ç”Ÿæˆåˆæ³•çš„å±æ€§åã€‚</span>
                    <span class="lang-en"><strong>Schema Constraint Generation:</strong> Inject domain Schema (e.g., Company has 'revenue' property) into the Prompt, restricting LLM to generate only valid property names.</span>
                </li>
                <li>
                    <span class="lang-zh"><strong>DSL ç”Ÿæˆï¼š</strong> ç”Ÿæˆæ ‡å‡†åŒ–çš„æŸ¥è¯¢è¯­å¥ã€‚</span>
                    <span class="lang-en"><strong>DSL Generation:</strong> Generate standardized query statements.</span>
                </li>
            </ol>

            <h4>
                <span class="lang-zh">ç¤ºä¾‹ï¼š</span>
                <span class="lang-en">Example:</span>
            </h4>
            <ul>
                <li>
                    <span class="lang-zh"><strong>è¾“å…¥ï¼š</strong> "Aå…¬å¸çš„å¤§è‚¡ä¸œè¿˜æŠ•èµ„äº†å“ªäº›å…¶ä»–ç§‘æŠ€å…¬å¸ï¼Ÿ"</span>
                    <span class="lang-en"><strong>Input:</strong> "Which other technology companies has Company Aâ€™s major shareholder invested in?"</span>
                </li>
                <li>
                    <span class="lang-zh"><strong>è¾“å‡ºè®¡åˆ’ (KGDSL ä¼ªä»£ç )ï¼š</strong></span>
                    <span class="lang-en"><strong>Output Plan (KGDSL Pseudo-code):</strong></span>
                </li>
            </ul>
            <pre class="lang-zh"><code class="language-text">// 1. å®ä½“é”šå®š (ç”± Entity Linking æ¨¡å—å®Œæˆï¼Œé LLM ç”Ÿæˆ)
$company_a = Entity(type="Company", id="1001")

// 2. ç¬¬ä¸€è·³éå†ï¼šæ‰¾å¤§è‚¡ä¸œ (Traversal 1)
// ä» Aå…¬å¸ è·³åˆ° äºº
$shareholder = $company_a.get_neighbor(relation="has_shareholder", role="major")

// 3. ç¬¬äºŒè·³éå†ï¼šæ‰¾æŠ•èµ„çš„å…¶ä»–å…¬å¸ (Traversal 2)
// ä» äºº è·³åˆ° å…¶ä»–å…¬å¸
$invested_companies = $shareholder.get_neighbor(relation="invested_in")

// 4. è¿‡æ»¤ï¼šåªä¿ç•™ç§‘æŠ€å…¬å¸ (Filtering)
$tech_companies = Filter($invested_companies, type="Technology")

// 5. è¿”å›ç»“æœ
Return $tech_companies.name</code></pre>
            <pre class="lang-en"><code class="language-text">// 1. Entity Anchoring (Done by Entity Linking module, not LLM generation)
$company_a = Entity(type="Company", id="1001")

// 2. First-hop traversal: find major shareholders (Traversal 1)
// From Company A â†’ Person
$shareholder = $company_a.get_neighbor(relation="has_shareholder", role="major")

// 3. Second-hop traversal: find other invested companies (Traversal 2)
// From Person â†’ Other companies
$invested_companies = $shareholder.get_neighbor(relation="invested_in")

// 4. Filtering: keep only technology companies (Filtering)
$tech_companies = Filter($invested_companies, type="Technology")

// 5. Return results
Return $tech_companies.name
</code></pre>

            <h4>
                <span class="lang-zh">å®ä½“é“¾æ¥å®ç°é€»è¾‘ (ä¼ªä»£ç )ï¼š</span>
                <span class="lang-en">Entity Linking Logic (Pseudo-code):</span>
            </h4>
            <pre class="lang-zh"><code class="language-python">class EntityLinker:
    def __init__(self, vector_db, graph_db, llm):
        self.vector_db = vector_db # å­˜å‚¨å®ä½“åçš„å‘é‡
        self.graph_db = graph_db   # å­˜å‚¨å›¾è°±ç»“æ„
        self.llm = llm

    def link(self, user_query: str, target_types: list = None) -> str:
        """
        è¾“å…¥ï¼šç”¨æˆ·Query
        è¾“å‡ºï¼šå›¾è°±ä¸­çš„å”¯ä¸€ Entity ID
        """
        # 1. [NER] æå–æŒ‡ç§°é¡¹ (Mention)
        mention = self.extract_mention(user_query) # e.g., "Aå…¬å¸"
        
        # 2. [Recall] æ··åˆå¬å›å€™é€‰é›†
        candidates = []
        # 2.1 å‘é‡å¬å› (å¤„ç†åˆ«å/ç®€ç§°)
        candidates.extend(self.vector_db.search(mention, top_k=5))
        # 2.2 å€’æ’ç´¢å¼•å¬å› (å¤„ç†ç²¾ç¡®åŒ¹é…/å­—é¢ç›¸ä¼¼)
        candidates.extend(self.graph_db.keyword_search(mention, top_k=5))
        
        # 3. [Filter] ç±»å‹è¿‡æ»¤
        if target_types:
            candidates = [c for c in candidates if c.type in target_types]

        # 4. [Rank] å®ä½“æ¶ˆæ­§ (LLM è£å†³)
        if len(candidates) == 1 or candidates[0].score > 0.95:
            return candidates[0].id
            
        return self.llm_disambiguate(user_query, candidates)</code></pre>
            <pre class="lang-en"><code class="language-python">class EntityLinker:
    def __init__(self, vector_db, graph_db, llm):
        self.vector_db = vector_db # Stores entity name vectors
        self.graph_db = graph_db   # Stores graph structure
        self.llm = llm

    def link(self, user_query: str, target_types: list = None) -> str:
        """
        Input: User Query
        Output: Unique Entity ID in Graph
        """
        # 1. [NER] Extract Mention
        mention = self.extract_mention(user_query) # e.g., "Company A"
        
        # 2. [Recall] Hybrid Candidate Recall
        candidates = []
        # 2.1 Vector Recall (Handle aliases/abbreviations)
        candidates.extend(self.vector_db.search(mention, top_k=5))
        # 2.2 Inverted Index Recall (Handle exact match/literal similarity)
        candidates.extend(self.graph_db.keyword_search(mention, top_k=5))
        
        # 3. [Filter] Type Filtering
        if target_types:
            candidates = [c for c in candidates if c.type in target_types]

        # 4. [Rank] Entity Disambiguation (LLM Judgment)
        if len(candidates) == 1 or candidates[0].score > 0.95:
            return candidates[0].id
            
        return self.llm_disambiguate(user_query, candidates)</code></pre>

            <h3 id="reasoning">
                <span class="lang-zh">4.2 æ¨ç†ä¸æ£€ç´¢ (Reasoning & Retrieval)</span>
                <span class="lang-en">4.2 Reasoning & Retrieval</span>
            </h3>
            <p class="lang-zh">æ‰§è¡Œé€»è¾‘è®¡åˆ’ï¼Œç»“åˆå›¾è°±éå†ä¸å‘é‡æ£€ç´¢ã€‚</p>
            <p class="lang-en">Execute the logic plan, combining graph traversal and vector retrieval.</p>
            <ol>
                <li>
                    <span class="lang-zh"><strong>é”šç‚¹å®šä½ (Anchor Retrieval)ï¼š</strong></span>
                    <span class="lang-en"><strong>Anchor Retrieval:</strong></span>
                    <ul>
                        <li>
                            <span class="lang-zh">å¦‚æœå®ä½“æ˜ç¡®ï¼Œç›´æ¥åœ¨å›¾è°±ä¸­å®šä½ã€‚</span>
                            <span class="lang-en">If the entity is explicit, locate it directly in the graph.</span>
                        </li>
                        <li>
                            <span class="lang-zh">å¦‚æœå®ä½“æ¨¡ç³Šï¼Œå…ˆé€šè¿‡å‘é‡æ£€ç´¢æ‰¾åˆ° Top-K Chunksï¼Œæå–å…¶ä¸­çš„å®ä½“ä½œä¸ºå›¾è°±æ¨ç†çš„â€œé”šç‚¹â€ã€‚</span>
                            <span class="lang-en">If the entity is ambiguous, first find Top-K Chunks via vector search, and extract entities within them as "anchors" for graph reasoning.</span>
                        </li>
                    </ul>
                </li>
                <li>
                    <span class="lang-zh"><strong>å¤šè·³æ¨ç†ä¸è®¡ç®—ï¼š</strong></span>
                    <span class="lang-en"><strong>Multi-hop Reasoning & Calculation:</strong></span>
                    <ul>
                        <li>
                            <span class="lang-zh">æ‰§è¡Œå›¾è°±éå†ï¼ˆTraversalï¼‰è·å–å¤šè·³å…³ç³»ã€‚</span>
                            <span class="lang-en">Execute Graph Traversal to get multi-hop relations.</span>
                        </li>
                        <li>
                            <span class="lang-zh">æ‰§è¡Œå±æ€§è¿‡æ»¤ï¼ˆFilteringï¼‰å’Œæ•°å€¼è®¡ç®—ï¼ˆCalculationï¼‰ã€‚</span>
                            <span class="lang-en">Execute Property Filtering and Calculation.</span>
                        </li>
                    </ul>
                </li>
                <li>
                    <span class="lang-zh"><strong>ä¸Šä¸‹æ–‡å¬å›ï¼š</strong> æ ¹æ®æ¨ç†è·¯å¾„ä¸Šçš„èŠ‚ç‚¹ï¼Œé€šè¿‡äº’ç´¢å¼•å¬å›å¯¹åº”çš„åŸå§‹æ–‡æœ¬ Chunkã€‚</span>
                    <span class="lang-en"><strong>Context Recall:</strong> Retrieve corresponding original text Chunks via mutual indexing based on nodes in the reasoning path.</span>
                </li>
            </ol>
        </section>

        <section id="analysis">
            <h2>
                <span class="lang-zh">5. æ–¹æ¡ˆåˆ†æä¸å·®è·å¯¹æ¯”</span>
                <span class="lang-en">5. Analysis & Gap Comparison</span>
            </h2>
            
            <h3>
                <span class="lang-zh">5.1 æ ¸å¿ƒä¼˜åŠ¿ (KAG å¢å¼º)</span>
                <span class="lang-en">5.1 Core Advantages (KAG Enhanced)</span>
            </h3>
            <ul>
                <li>
                    <span class="lang-zh"><strong>é€»è¾‘å¯è§£é‡Šï¼š</strong> é€šè¿‡ Solver æœºåˆ¶ï¼Œèƒ½å¤Ÿå¤„ç†æ•°å€¼è®¡ç®—å’Œé€»è¾‘æ¨ç†é—®é¢˜ï¼Œè€Œéä»…é æ¦‚ç‡ç”Ÿæˆã€‚</span>
                    <span class="lang-en"><strong>Logical Interpretability:</strong> Via the Solver mechanism, it handles numerical calculation and logical reasoning, not just probabilistic generation.</span>
                </li>
                <li>
                    <span class="lang-zh"><strong>çŸ¥è¯†ç²¾åº¦é«˜ï¼š</strong> Schema-First æœºåˆ¶ä¿è¯äº†çŸ¥è¯†æŠ½å–çš„è§„èŒƒæ€§ï¼Œå‡å°‘äº†è„æ•°æ®ã€‚</span>
                    <span class="lang-en"><strong>High Knowledge Precision:</strong> Schema-First mechanism ensures standardized knowledge extraction, reducing dirty data.</span>
                </li>
                <li>
                    <span class="lang-zh"><strong>æ··åˆæ£€ç´¢èƒ½åŠ›ï¼š</strong> äº’ç´¢å¼•æœºåˆ¶è§£å†³äº†â€œæœ‰å›¾æ— æ–‡â€æˆ–â€œæœ‰æ–‡æ— å›¾â€çš„å‰²è£‚é—®é¢˜ã€‚</span>
                    <span class="lang-en"><strong>Hybrid Retrieval:</strong> Mutual indexing solves the fragmentation issue of "Graph without Text" or "Text without Graph".</span>
                </li>
                <li>
                    <span class="lang-zh"><strong>æ—¶åºæ„ŸçŸ¥ï¼š</strong> äº‹ä»¶ç±»å‹çš„å¼•å…¥ä½¿å¾—ç³»ç»Ÿå…·å¤‡äº†å¤„ç†æ—¶é—´çº¿é—®é¢˜çš„èƒ½åŠ›ã€‚</span>
                    <span class="lang-en"><strong>Temporal Awareness:</strong> The introduction of Event types enables the system to handle timeline issues.</span>
                </li>
            </ul>

            <div class="warning-box">
                <h3>
                    <span class="lang-zh">5.2 ä¸åŸç”Ÿ KAG/OpenSPG çš„å·®è·åˆ†æ</span>
                    <span class="lang-en">5.2 Gap Analysis with Native KAG/OpenSPG</span>
                </h3>
                <p class="lang-zh">æœ¬æ–¹æ¡ˆæ˜¯ä¸€ä¸ªè½»é‡çº§çš„ KAG å®ç°ï¼Œä½†åœ¨ä»¥ä¸‹æ–¹é¢ä¸åŸç”Ÿ OpenSPG å¼•æ“å­˜åœ¨å·®è·ï¼š</p>
                <p class="lang-en">This proposal is a lightweight KAG implementation, but gaps exist compared to the native OpenSPG engine in the following areas:</p>
                
                <h4>
                    <span class="lang-zh">ç¼ºå¤± SPG çš„â€œå¯ç¼–ç¨‹æ€§â€ (The "Programmable" in SPG)</span>
                    <span class="lang-en">Missing "Programmability" of SPG</span>
                </h4>
                <ul>
                    <li>
                        <span class="lang-zh"><strong>KAG/OpenSPG åŸç”Ÿèƒ½åŠ›ï¼š</strong> SPG ä¸ä»…ä»…æ˜¯å®šä¹‰å±æ€§ï¼Œå®ƒå…è®¸åœ¨ Schema ä¸­<strong>ç›´æ¥å®šä¹‰é€»è¾‘è§„åˆ™</strong>ã€‚</span>
                        <span class="lang-en"><strong>Native KAG/OpenSPG Capability:</strong> SPG is not just about defining properties; it allows defining <strong>logic rules directly in the Schema</strong>.</span>
                        <br><em class="lang-zh">ä¾‹å­ï¼š</em><em class="lang-en">Example:</em> 
                        <span class="lang-zh">å¯ä»¥åœ¨ Schema ä¸­å®šä¹‰è§„åˆ™ï¼š<code>å¦‚æœ A æŒè‚¡ B > 50%ï¼Œåˆ™ A æ§åˆ¶ B</code>ã€‚å½“æ•°æ®å†™å…¥æ—¶ï¼ŒSPG å¼•æ“ä¼šè‡ªåŠ¨æ¨ç†å‡ºâ€œæ§åˆ¶â€å…³ç³»ï¼Œè€Œä¸éœ€è¦åœ¨æŸ¥è¯¢æ—¶ä¸´æ—¶è®¡ç®—ã€‚</span>
                        <span class="lang-en">You can define a rule: <code>If A holds > 50% of B, then A controls B</code>. The SPG engine automatically infers the "Control" relation at write time, avoiding ad-hoc calculation at query time.</span>
                    </li>
                    <li>
                        <span class="lang-zh"><strong>æœ¬æ–¹æ¡ˆè®¾è®¡ï¼š</strong> ç›®å‰çš„ Schema (3.1) ä¸»è¦æ˜¯é™æ€çš„ç±»å‹å’Œå±æ€§å®šä¹‰ï¼ˆPython Classï¼‰ï¼Œç¼ºå°‘äº†åµŒå…¥ Schema çš„åŠ¨æ€é€»è¾‘è§„åˆ™ã€‚</span>
                        <span class="lang-en"><strong>Current Design:</strong> The current Schema (3.1) is mainly static type and property definitions (Python Class), lacking dynamic logic rules embedded in the Schema.</span>
                    </li>
                    <li>
                        <span class="lang-zh"><strong>å½±å“ï¼š</strong> å¯¹äºæå…¶å¤æ‚çš„éšå¼å…³ç³»æ¨ç†ï¼Œæœ¬æ–¹æ¡ˆéœ€è¦åœ¨æŸ¥è¯¢é˜¶æ®µï¼ˆQuery Timeï¼‰åšæ›´å¤šå·¥ä½œï¼Œè€Œ SPG æ˜¯åœ¨å†™å…¥é˜¶æ®µï¼ˆWrite Timeï¼‰æˆ–é¢„è®¡ç®—é˜¶æ®µå®Œæˆï¼ŒæŸ¥è¯¢æ•ˆç‡æ›´é«˜ã€‚</span>
                        <span class="lang-en"><strong>Impact:</strong> For extremely complex implicit relation reasoning, this scheme requires more work at Query Time, whereas SPG completes it at Write Time or pre-calculation, resulting in higher query efficiency.</span>
                    </li>
                </ul>
            </div>
        </section>

        <!-- æ–°å¢å‚è€ƒæ–‡çŒ®ç« èŠ‚ -->
        <section id="references">
            <h2>
                <span class="lang-zh">6. å‚è€ƒæ–‡çŒ®</span>
                <span class="lang-en">6. References</span>
            </h2>
            <ul class="ref-list">
                <li>
                    <span class="lang-zh"><strong>[1] èš‚èšé›†å›¢è¯­ä¹‰å¢å¼ºå¯ç¼–ç¨‹çŸ¥è¯†å›¾è°± SPG:</strong></span>
                    <span class="lang-en"><strong>[1] Ant Group Semantic-enhanced Programmable Graph (SPG):</strong></span>
                    <br>
                    <a href="https://github.com/winer632/graph-rag-doc/releases/download/V2.1/SPG.pdf" target="_blank">https://github.com/winer632/graph-rag-doc/releases/download/V2.1/SPG.pdf</a>
                </li>
                <li>
                    <span class="lang-zh"><strong>[2] OpenSPG/KAG GitHub ä»£ç åº“:</strong></span>
                    <span class="lang-en"><strong>[2] OpenSPG/KAG GitHub Repository:</strong></span>
                    <br>
                    <a href="https://github.com/OpenSPG/KAG" target="_blank">https://github.com/OpenSPG/KAG</a>
                </li>
            </ul>
        </section>

        <footer>
            <p style="text-align: center; margin-top: 4rem; color: #6b7280; font-size: 0.9rem;">
                Generated for Graph-RAG Implementation Guide (KAG Enhanced)
            </p>
        </footer>
    </main>

    <script>
        function switchLanguage(lang) {
            if (lang === 'en') {
                document.body.classList.add('en-mode');
            } else {
                document.body.classList.remove('en-mode');
            }
        }
    </script>
</body>
</html>
